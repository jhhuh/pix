{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pix","text":"<p>Explore Nix internals through readable Python.</p> <p>Nix's core algorithms \u2014 store path hashing, NAR serialization, derivation parsing, the daemon wire protocol \u2014 are buried in C++ across dozens of source files. pix re-derives each one in straightforward Python so you can read, modify, and single-step through the logic.</p> <p>Every module produces output identical to the real <code>nix</code> CLI, verified by the test suite. The code is the documentation; these pages are the commentary.</p>"},{"location":"#whats-inside-nix","title":"What's inside Nix","text":"<p>When you run <code>nix build</code>, a lot happens under the hood. pix breaks it into pieces you can understand one at a time:</p> Concept What Nix does pix module Docs Base32 Custom encoding for store path hashes \u2014 not RFC 4648 <code>base32.py</code> How it differs Hash compression XOR-folds SHA-256 (32 B) down to 160 bits (20 B) <code>hash.py</code> In store path computation NAR Deterministic archive format \u2014 no timestamps, no uid, just content <code>nar.py</code> Wire format spec Store paths <code>/nix/store/&lt;hash&gt;-&lt;name&gt;</code> computed from a fingerprint string <code>store_path.py</code> Full algorithm Derivations <code>.drv</code> files in ATerm format; <code>hashDerivationModulo</code> breaks circular deps <code>derivation.py</code> Format + hashing Daemon protocol Unix socket with uint64-LE framing, stderr log stream, operation opcodes <code>daemon.py</code> Protocol spec"},{"location":"#reading-order","title":"Reading order","text":"<p>The modules build on each other. Start from the bottom:</p> <pre><code>1. base32.py        \u2190 simplest: just an encoding\n2. hash.py          \u2190 one function: XOR-fold\n3. nar.py           \u2190 serialization format, uses hash\n4. store_path.py    \u2190 the core algorithm, uses base32 + hash\n5. derivation.py    \u2190 parsing + the hashDerivationModulo trick\n6. daemon.py        \u2190 standalone: wire protocol over Unix socket\n</code></pre> <p>Each file is self-contained and under 150 lines. You can read the entire codebase in one sitting.</p>"},{"location":"#try-it-yourself","title":"Try it yourself","text":"<pre><code>nix develop\n\n# See that pix computes the exact same hash as nix\npython -m pix hash-path ./pix/base32.py --base32\nnix hash path ./pix/base32.py --type sha256 --base32\n# same output\n\n# Compute a store path, then verify via the daemon\npython -m pix store-path ./pix --name pix-source\npython -m pix add-text hello.txt \"hello world\"\npython -m pix drv-show /nix/store/...-hello.drv\n</code></pre>"},{"location":"#verify","title":"Verify","text":"<pre><code>pytest tests/ -v   # 28 tests, all comparing against real nix\n</code></pre>"},{"location":"#how-to-use-these-docs","title":"How to use these docs","text":"<ul> <li>Internals \u2014 Start here. Explains how Nix works with diagrams, hex dumps, and protocol traces.</li> <li>API Reference \u2014 Function signatures and usage examples for each module.</li> <li>CLI Reference \u2014 The <code>python -m pix</code> commands for quick experimentation.</li> </ul>"},{"location":"cli/","title":"CLI Reference","text":"<p>Run pix as a Python module:</p> <pre><code>python -m pix &lt;command&gt; [options]\n</code></pre>"},{"location":"cli/#commands","title":"Commands","text":""},{"location":"cli/#hash-path-nar-hash-of-a-path","title":"<code>hash-path</code> \u2014 NAR hash of a path","text":"<p>Compute the SHA-256 hash of the NAR serialization of a file or directory. Equivalent to <code>nix hash path</code>.</p> <pre><code>python -m pix hash-path &lt;path&gt; [--base32]\n</code></pre> Flag Description <code>--base32</code> Output in Nix base32 instead of hex <p>Examples:</p> <pre><code>$ python -m pix hash-path ./pix/base32.py\nsha256:0a43087...\n\n$ python -m pix hash-path ./pix/base32.py --base32\nsha256:1l1a9cfyhln3s40sb9b2w2h4z8p3566xkbs84vk819h3107ahkvl\n\n$ python -m pix hash-path ./my-directory --base32\nsha256:1vrbglcwc4gpln263rg69jq6vgq8p3ibspdg7lzyxcyc0ryg5wn2\n</code></pre> <p>Note</p> <p><code>hash-path</code> hashes the NAR serialization, not the raw file bytes. This includes file type metadata and, for directories, sorted entry names. Use <code>hash-file</code> for raw content hashing.</p>"},{"location":"cli/#hash-file-flat-sha-256-of-a-file","title":"<code>hash-file</code> \u2014 Flat SHA-256 of a file","text":"<p>Hash the raw bytes of a file (no NAR wrapping). Equivalent to <code>nix hash file</code>.</p> <pre><code>python -m pix hash-file &lt;path&gt; [--base32]\n</code></pre> <p>Examples:</p> <pre><code>$ echo -n \"hello\" &gt; /tmp/hello.txt\n$ python -m pix hash-file /tmp/hello.txt --base32\nsha256:094qif9n4cq4fdg459qzbhg1c6wywawwaaivx0k0x8xhbyx4vwic\n</code></pre>"},{"location":"cli/#store-path-compute-store-path","title":"<code>store-path</code> \u2014 Compute store path","text":"<p>Compute the Nix store path for a local file or directory, as if it were added via <code>builtins.path</code> or <code>filterSource</code>.</p> <pre><code>python -m pix store-path &lt;path&gt; [--name NAME]\n</code></pre> Flag Description <code>--name</code> Override the store object name (default: basename of path) <p>Examples:</p> <pre><code>$ python -m pix store-path ./my-source\n/nix/store/pagr3c3r57k8h9zqhb89cqihhc9sbz03-my-source\n\n$ python -m pix store-path ./my-source --name custom-name\n/nix/store/abc123...-custom-name\n</code></pre>"},{"location":"cli/#drv-show-parse-drv-as-json","title":"<code>drv-show</code> \u2014 Parse <code>.drv</code> as JSON","text":"<p>Parse a <code>.drv</code> file from the Nix store and display it as formatted JSON. Equivalent to <code>nix derivation show</code>.</p> <pre><code>python -m pix drv-show &lt;drv-path&gt;\n</code></pre> <p>Example:</p> <pre><code>$ python -m pix drv-show /nix/store/...-hello-2.12.2.drv\n{\n  \"outputs\": {\n    \"out\": {\n      \"path\": \"/nix/store/...-hello-2.12.2\",\n      \"hashAlgo\": \"\",\n      \"hash\": \"\"\n    }\n  },\n  \"inputDrvs\": {\n    \"/nix/store/...-bash.drv\": [\"out\"],\n    \"/nix/store/...-stdenv.drv\": [\"out\"]\n  },\n  \"inputSrcs\": [\"/nix/store/...-default-builder.sh\"],\n  \"platform\": \"x86_64-linux\",\n  \"builder\": \"/nix/store/...-bash/bin/bash\",\n  \"args\": [\"-e\", \"/nix/store/...-default-builder.sh\"],\n  \"env\": {\"name\": \"hello\", \"version\": \"2.12.2\", ...}\n}\n</code></pre>"},{"location":"cli/#path-info-query-store-path-info","title":"<code>path-info</code> \u2014 Query store path info","text":"<p>Query metadata for a store path from the Nix daemon. Requires a running daemon.</p> <pre><code>python -m pix path-info &lt;store-path&gt;\n</code></pre> <p>Example:</p> <pre><code>$ python -m pix path-info /nix/store/...-hello-2.12.2\nderiver: /nix/store/...-hello-2.12.2.drv\nnar-hash: sha256:1abc...\nnar-size: 53856\nreferences: /nix/store/...-glibc /nix/store/...-hello-2.12.2\nsigs: cache.nixos.org-1:abc123...\n</code></pre>"},{"location":"cli/#is-valid-check-store-path-validity","title":"<code>is-valid</code> \u2014 Check store path validity","text":"<p>Check whether a store path exists and is valid. Exits 0 if valid, 1 if not.</p> <pre><code>python -m pix is-valid &lt;store-path&gt;\n</code></pre> <p>Example:</p> <pre><code>$ python -m pix is-valid /nix/store/...-hello-2.12.2\nvalid\n\n$ python -m pix is-valid /nix/store/aaaa...-nonexistent\ninvalid\n</code></pre>"},{"location":"cli/#add-text-add-text-to-the-store","title":"<code>add-text</code> \u2014 Add text to the store","text":"<p>Add a text string to the Nix store, like <code>builtins.toFile</code>. Reads from stdin if content is <code>-</code> or omitted.</p> <pre><code>python -m pix add-text &lt;name&gt; [content]\n</code></pre> <p>Examples:</p> <pre><code>$ python -m pix add-text hello.txt \"hello world\"\n/nix/store/qbfcv31xi1wjisxwl4b2nk1a8jqxbcf5-hello.txt\n\n$ echo \"from stdin\" | python -m pix add-text piped.txt\n/nix/store/...-piped.txt\n</code></pre>"},{"location":"cli/#build-build-store-paths","title":"<code>build</code> \u2014 Build store paths","text":"<p>Build one or more derivation outputs via the Nix daemon.</p> <pre><code>python -m pix build &lt;path&gt;...\n</code></pre> <p>Example:</p> <pre><code>$ python -m pix build /nix/store/...-hello-2.12.2.drv^out\nbuild succeeded\n</code></pre>"},{"location":"api/","title":"API Reference","text":"<p>Each module is a self-contained, readable implementation of one Nix concept. No external dependencies \u2014 stdlib only.</p>"},{"location":"api/#modules","title":"Modules","text":"Module Lines What it implements <code>pix.base32</code> ~40 The Nix base32 encoding \u2014 custom alphabet, reversed bit extraction <code>pix.hash</code> ~20 SHA-256 wrapper + XOR-fold compression <code>pix.nar</code> ~80 NAR archive serialization (files, dirs, symlinks) <code>pix.store_path</code> ~70 Store path fingerprinting for text, source, fixed-output, and derivation outputs <code>pix.derivation</code> ~250 ATerm parser/serializer + <code>hashDerivationModulo</code> <code>pix.daemon</code> ~270 Unix socket client: handshake, stderr draining, store operations"},{"location":"api/#dependency-graph","title":"Dependency graph","text":"<pre><code>daemon  (standalone \u2014 wire protocol only)\n\nstore_path \u2500\u2500\u2500 hash\n    \u2502            \u2502\n    \u2514\u2500\u2500 base32   \u2502\n                 \u2502\nnar \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nderivation \u2500\u2500\u2500 hash\n</code></pre> <p>No circular dependencies. <code>daemon</code> is fully independent \u2014 it speaks the binary protocol directly without needing local hash computation.</p>"},{"location":"api/#reading-the-code","title":"Reading the code","text":"<p>The modules are designed to be read top-to-bottom. Each file starts with a docstring explaining the format or protocol, then implements it in the most straightforward way possible.</p> <p>If you want to understand why the algorithms work the way they do, see the Internals section. If you want to see how they're implemented, read the source \u2014 it's all in <code>pix/</code>.</p>"},{"location":"api/base32/","title":"pix.base32","text":"<p>Nix-specific base32 encoding and decoding.</p> <p>Warning</p> <p>This is not RFC 4648 base32. Nix uses a different alphabet and a different bit-extraction order. See Internals: Base32 for the full comparison.</p>"},{"location":"api/base32/#constants","title":"Constants","text":""},{"location":"api/base32/#chars","title":"<code>CHARS</code>","text":"<pre><code>CHARS = \"0123456789abcdfghijklmnpqrsvwxyz\"\n</code></pre> <p>The 32-character Nix base32 alphabet. Notable omissions: <code>e</code>, <code>o</code>, <code>t</code>, <code>u</code>.</p>"},{"location":"api/base32/#functions","title":"Functions","text":""},{"location":"api/base32/#encodedata-bytes-str","title":"<code>encode(data: bytes) -&gt; str</code>","text":"<p>Encode bytes to a Nix base32 string.</p> <p>Output length: <code>ceil(n * 8 / 5)</code> characters for <code>n</code> input bytes.</p> Input size Output size Used for 20 bytes 32 chars Store path hashes 32 bytes 52 chars SHA-256 digests <pre><code>from pix.base32 import encode\n\nencode(b\"\\x00\" * 20)\n# '00000000000000000000000000000000'\n\nimport hashlib\ndigest = hashlib.sha256(b\"hello\").digest()\nencode(digest)\n# '094qif9n4cq4fdg459qzbhg1c6wywawwaaivx0k0x8xhbyx4vwic'\n</code></pre>"},{"location":"api/base32/#decodes-str-bytes","title":"<code>decode(s: str) -&gt; bytes</code>","text":"<p>Decode a Nix base32 string back to bytes.</p> <p>Raises: <code>ValueError</code> if the string contains characters not in the Nix base32 alphabet.</p> <pre><code>from pix.base32 import decode\n\ndecode(\"094qif9n4cq4fdg459qzbhg1c6wywawwaaivx0k0x8xhbyx4vwic\")\n# b',\\xf2M\\xba_\\xb0\\xa3\\x0e&amp;\\xe8;*\\xc5\\xb9\\xe2\\x9e\\x1b\\x16\\x1e\\\\\\x1f\\xa7B^s\\x043b\\x93\\x8b\\x98$'\n\ndecode(\"00000000000000000000000000000000\")\n# b'\\x00' * 20\n</code></pre>"},{"location":"api/base32/#roundtrip","title":"Roundtrip","text":"<p>Encode and decode are inverse operations:</p> <pre><code>from pix.base32 import encode, decode\n\ndata = b\"any bytes here\"\nassert decode(encode(data)) == data\n</code></pre>"},{"location":"api/daemon/","title":"pix.daemon","text":"<p>Nix daemon Unix socket client. Communicates using the Nix worker protocol over <code>/nix/var/nix/daemon-socket/socket</code>.</p> <p>See Internals: Daemon Protocol for protocol details.</p>"},{"location":"api/daemon/#classes","title":"Classes","text":""},{"location":"api/daemon/#daemonconnection","title":"<code>DaemonConnection</code>","text":"<p>Context manager for a connection to the Nix daemon.</p> <pre><code>from pix.daemon import DaemonConnection\n\nwith DaemonConnection() as conn:\n    # use conn...\n    pass\n\n# Or with a custom socket path:\nwith DaemonConnection(\"/custom/socket/path\") as conn:\n    pass\n</code></pre> <p>Constructor:</p> <pre><code>DaemonConnection(socket_path: str | None = None)\n</code></pre> Parameter Default Description <code>socket_path</code> <code>/nix/var/nix/daemon-socket/socket</code> Unix socket path <p>Attributes:</p> Attribute Type Description <code>daemon_version</code> <code>int</code> Protocol version after handshake (e.g. <code>293</code> = 1.37)"},{"location":"api/daemon/#operations","title":"Operations","text":""},{"location":"api/daemon/#is_valid_pathpath-str-bool","title":"<code>is_valid_path(path: str) -&gt; bool</code>","text":"<p>Check if a store path exists and is valid in the Nix store.</p> <pre><code>with DaemonConnection() as conn:\n    conn.is_valid_path(\"/nix/store/...-hello-2.12.2\")  # True\n    conn.is_valid_path(\"/nix/store/aaaa...-nope\")       # False\n</code></pre>"},{"location":"api/daemon/#query_valid_pathspaths-liststr-substitute-bool-false-setstr","title":"<code>query_valid_paths(paths: list[str], substitute: bool = False) -&gt; set[str]</code>","text":"<p>Batch validity check. Returns the subset of paths that are valid.</p> <pre><code>with DaemonConnection() as conn:\n    valid = conn.query_valid_paths([\n        \"/nix/store/...-hello\",\n        \"/nix/store/...-nonexistent\",\n    ])\n    # {'/nix/store/...-hello'}\n</code></pre> Parameter Description <code>substitute</code> If <code>True</code>, attempt to substitute missing paths"},{"location":"api/daemon/#query_path_infopath-str-pathinfo","title":"<code>query_path_info(path: str) -&gt; PathInfo</code>","text":"<p>Query metadata for a valid store path.</p> <p>Raises: <code>NixDaemonError</code> if the path is not valid.</p> <pre><code>with DaemonConnection() as conn:\n    info = conn.query_path_info(\"/nix/store/...-hello-2.12.2\")\n    info.deriver       # '/nix/store/...-hello-2.12.2.drv'\n    info.nar_hash       # 'sha256:1abc...'\n    info.nar_size       # 53856\n    info.references     # ['/nix/store/...-glibc', ...]\n    info.sigs           # ['cache.nixos.org-1:abc...']\n</code></pre>"},{"location":"api/daemon/#add_text_to_storename-str-content-str-references-liststr-none-none-str","title":"<code>add_text_to_store(name: str, content: str, references: list[str] | None = None) -&gt; str</code>","text":"<p>Add a text string to the Nix store. Returns the store path.</p> <p>Like <code>builtins.toFile</code> \u2014 creates a regular file with the given content.</p> <pre><code>with DaemonConnection() as conn:\n    path = conn.add_text_to_store(\"hello.txt\", \"hello world\")\n    # '/nix/store/qbfcv31xi1wjisxwl4b2nk1a8jqxbcf5-hello.txt'\n\n    # With references (the text depends on another store path):\n    path = conn.add_text_to_store(\n        \"wrapper.sh\",\n        \"#!/bin/sh\\nexec /nix/store/...-program/bin/prog\",\n        references=[\"/nix/store/...-program\"]\n    )\n</code></pre>"},{"location":"api/daemon/#build_pathspaths-liststr-build_mode-int-0-none","title":"<code>build_paths(paths: list[str], build_mode: int = 0) -&gt; None</code>","text":"<p>Build one or more store paths. For derivations, use the <code>&lt;drv-path&gt;^&lt;output&gt;</code> syntax.</p> <p>Raises: <code>NixDaemonError</code> on build failure.</p> <pre><code>with DaemonConnection() as conn:\n    # Build a derivation output\n    conn.build_paths([\"/nix/store/...-hello.drv^out\"])\n\n    # Substitute/build multiple paths\n    conn.build_paths([\n        \"/nix/store/...-hello.drv^out\",\n        \"/nix/store/...-world.drv^out\",\n    ])\n</code></pre> <code>build_mode</code> Meaning <code>0</code> Normal (build or substitute) <code>1</code> Repair <code>2</code> Check"},{"location":"api/daemon/#data-classes","title":"Data classes","text":""},{"location":"api/daemon/#pathinfo","title":"<code>PathInfo</code>","text":"<p>Returned by <code>query_path_info</code>.</p> <pre><code>@dataclass\nclass PathInfo:\n    deriver: str            # .drv path that produced this, or \"\"\n    nar_hash: str           # NAR hash as string\n    references: list[str]   # store paths this depends on\n    registration_time: int  # unix timestamp\n    nar_size: int           # size of NAR serialization in bytes\n    sigs: list[str]         # signatures\n</code></pre>"},{"location":"api/daemon/#exceptions","title":"Exceptions","text":""},{"location":"api/daemon/#nixdaemonerror","title":"<code>NixDaemonError</code>","text":"<p>Raised on protocol errors, invalid paths, build failures, etc.</p> <pre><code>from pix.daemon import DaemonConnection, NixDaemonError\n\nwith DaemonConnection() as conn:\n    try:\n        conn.query_path_info(\"/nix/store/invalid-path\")\n    except NixDaemonError as e:\n        print(f\"Daemon error: {e}\")\n</code></pre>"},{"location":"api/derivation/","title":"pix.derivation","text":"<p>Parse and serialize Nix <code>.drv</code> files (ATerm format), and compute derivation hashes for output path calculation.</p> <p>See Internals: Derivations for the ATerm format specification.</p>"},{"location":"api/derivation/#data-classes","title":"Data classes","text":""},{"location":"api/derivation/#derivationoutput","title":"<code>DerivationOutput</code>","text":"<pre><code>@dataclass\nclass DerivationOutput:\n    path: str        # output store path (empty for content-addressed)\n    hash_algo: str   # \"\" for normal outputs, \"sha256\" etc. for fixed-output\n    hash_value: str  # \"\" for normal outputs, hex hash for fixed-output\n</code></pre>"},{"location":"api/derivation/#derivation","title":"<code>Derivation</code>","text":"<pre><code>@dataclass\nclass Derivation:\n    outputs: dict[str, DerivationOutput]     # \"out\" -&gt; DerivationOutput(...)\n    input_drvs: dict[str, list[str]]         # drv_path -&gt; [\"out\", ...]\n    input_srcs: list[str]                    # source store paths\n    platform: str                            # \"x86_64-linux\"\n    builder: str                             # \"/nix/store/...-bash/bin/bash\"\n    args: list[str]                          # builder arguments\n    env: dict[str, str]                      # environment variables\n</code></pre>"},{"location":"api/derivation/#functions","title":"Functions","text":""},{"location":"api/derivation/#parsedrv_text-str-derivation","title":"<code>parse(drv_text: str) -&gt; Derivation</code>","text":"<p>Parse an ATerm <code>.drv</code> file into a <code>Derivation</code>.</p> <pre><code>from pix.derivation import parse\n\ndrv = parse(open(\"/nix/store/...-hello-2.12.2.drv\").read())\n\ndrv.platform       # 'x86_64-linux'\ndrv.builder         # '/nix/store/...-bash/bin/bash'\ndrv.outputs.keys()  # dict_keys(['out'])\ndrv.env['name']     # 'hello'\n</code></pre> <p>Handles escape sequences in strings: <code>\\\\</code>, <code>\\\"</code>, <code>\\n</code>, <code>\\r</code>, <code>\\t</code>.</p>"},{"location":"api/derivation/#serializedrv-derivation-str","title":"<code>serialize(drv: Derivation) -&gt; str</code>","text":"<p>Serialize a <code>Derivation</code> back to ATerm <code>.drv</code> format.</p> <p>Output is deterministic:</p> <ul> <li>Outputs sorted by name</li> <li>Input derivations sorted by path</li> <li>Input sources sorted</li> <li>Environment variables sorted by key</li> <li>Strings properly escaped</li> </ul> <pre><code>from pix.derivation import parse, serialize\n\ntext = open(\"/nix/store/...-hello.drv\").read()\ndrv = parse(text)\nassert parse(serialize(drv)) == drv  # roundtrip\n</code></pre>"},{"location":"api/derivation/#hash_derivation_modulodrv-derivation-drv_hashes-dictstr-bytes-none-none-bytes","title":"<code>hash_derivation_modulo(drv: Derivation, drv_hashes: dict[str, bytes] | None = None) -&gt; bytes</code>","text":"<p>Compute the modular hash of a derivation, used for output path computation.</p> <p>Fixed-output derivations (single output <code>\"out\"</code> with <code>hash_algo</code> set):</p> <pre><code>sha256(\"fixed:out:&lt;hash_algo&gt;:&lt;hash_value&gt;:\")\n</code></pre> <p>Regular derivations: Creates a masked copy where output paths are blanked and input derivation paths are replaced by their modular hashes, then hashes the resulting ATerm.</p> <pre><code>from pix.derivation import parse, hash_derivation_modulo\n\ndrv = parse(open(\"some.drv\").read())\n\n# For fixed-output:\nh = hash_derivation_modulo(drv)\n\n# For regular derivations, provide input drv hashes:\nh = hash_derivation_modulo(drv, drv_hashes={\n    \"/nix/store/...-dep.drv\": dep_hash,\n})\n</code></pre> <p>Warning</p> <p>For regular (non-fixed-output) derivations, you must provide the modular hashes of all input derivations via the <code>drv_hashes</code> parameter. Missing hashes raise <code>ValueError</code>.</p>"},{"location":"api/derivation/#example-full-derivation-inspection","title":"Example: Full derivation inspection","text":"<pre><code>from pix.derivation import parse\nimport json\n\ndrv = parse(open(\"/nix/store/...-hello-2.12.2.drv\").read())\n\nprint(f\"Package: {drv.env.get('pname', drv.env.get('name', '?'))}\")\nprint(f\"Version: {drv.env.get('version', '?')}\")\nprint(f\"System:  {drv.platform}\")\nprint(f\"Builder: {drv.builder}\")\nprint(f\"Outputs: {list(drv.outputs.keys())}\")\nprint(f\"Dependencies: {len(drv.input_drvs)} derivations, {len(drv.input_srcs)} sources\")\n</code></pre>"},{"location":"api/hash/","title":"pix.hash","text":"<p>Hash utilities for Nix store path computation.</p>"},{"location":"api/hash/#functions","title":"Functions","text":""},{"location":"api/hash/#sha256data-bytes-bytes","title":"<code>sha256(data: bytes) -&gt; bytes</code>","text":"<p>Compute SHA-256 digest. Thin wrapper around <code>hashlib.sha256</code>.</p> <pre><code>from pix.hash import sha256\n\nsha256(b\"hello\")\n# b',\\xf2M\\xba_\\xb0\\xa3\\x0e...' (32 bytes)\n</code></pre>"},{"location":"api/hash/#sha256_hexdata-bytes-str","title":"<code>sha256_hex(data: bytes) -&gt; str</code>","text":"<p>Compute SHA-256 digest as a hex string.</p> <pre><code>from pix.hash import sha256_hex\n\nsha256_hex(b\"hello\")\n# '2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824'\n</code></pre>"},{"location":"api/hash/#compress_hashhash_bytes-bytes-size-int-bytes","title":"<code>compress_hash(hash_bytes: bytes, size: int) -&gt; bytes</code>","text":"<p>XOR-fold a hash to a shorter length.</p> <p>This is how Nix truncates SHA-256 (32 bytes) to 160 bits (20 bytes) for store path hashes. It is not simple truncation \u2014 every byte of the input contributes to the output via XOR.</p> <p>Algorithm:</p> <pre><code>result = bytearray(size)       # zero-initialized\nfor i, b in enumerate(hash_bytes):\n    result[i % size] ^= b      # XOR each byte into position\n</code></pre> <p>Example:</p> <pre><code>from pix.hash import compress_hash, sha256\n\ndigest = sha256(b\"hello\")           # 32 bytes\ncompressed = compress_hash(digest, 20)  # 20 bytes\n\n# Bytes 0..19 of the digest are XOR'd with bytes 20..31\n# compressed[0] = digest[0] ^ digest[20]\n# compressed[1] = digest[1] ^ digest[21]\n# ...\n# compressed[11] = digest[11] ^ digest[31]\n# compressed[12..19] = digest[12..19]  (no folding needed)\n</code></pre> <p>Info</p> <p>XOR-fold preserves more entropy than truncation. Every bit of the original hash affects the compressed output.</p>"},{"location":"api/nar/","title":"pix.nar","text":"<p>NAR (Nix Archive) serialization and hashing.</p> <p>NAR is a deterministic archive format. Unlike tar, it produces identical output for identical filesystem content regardless of timestamps, ownership, or permissions (only the executable bit is preserved).</p> <p>See Internals: NAR Format for the wire format specification.</p>"},{"location":"api/nar/#functions","title":"Functions","text":""},{"location":"api/nar/#nar_serializepath-str-path-bytes","title":"<code>nar_serialize(path: str | Path) -&gt; bytes</code>","text":"<p>Serialize a filesystem path (file, directory, or symlink) to NAR bytes.</p> <pre><code>from pix.nar import nar_serialize\n\n# Serialize a single file\nnar = nar_serialize(\"/tmp/hello.txt\")\n\n# Serialize a directory (entries sorted by name)\nnar = nar_serialize(\"/path/to/my-source\")\n</code></pre> <p>Behavior:</p> <ul> <li>Regular files: Serialized with contents and executable flag</li> <li>Symlinks: Serialized with symlink target (not resolved)</li> <li>Directories: Entries sorted lexicographically by name, recursed</li> <li>Other types: Raises <code>ValueError</code></li> </ul>"},{"location":"api/nar/#nar_hashpath-str-path-bytes","title":"<code>nar_hash(path: str | Path) -&gt; bytes</code>","text":"<p>Compute the SHA-256 hash of the NAR serialization. Returns 32 raw bytes.</p> <p>This is what <code>nix hash path</code> computes.</p> <pre><code>from pix.nar import nar_hash\n\ndigest = nar_hash(\"./my-file.txt\")  # 32 bytes\ndigest.hex()\n# 'a1b2c3d4...'\n</code></pre>"},{"location":"api/nar/#nar_hash_hexpath-str-path-str","title":"<code>nar_hash_hex(path: str | Path) -&gt; str</code>","text":"<p>Same as <code>nar_hash</code> but returns hex string directly.</p> <pre><code>from pix.nar import nar_hash_hex\n\nnar_hash_hex(\"./my-file.txt\")\n# 'a1b2c3d4...'\n</code></pre>"},{"location":"api/nar/#combining-with-other-modules","title":"Combining with other modules","text":"<p>NAR hashing is the first step in computing store paths for source imports:</p> <pre><code>from pix.nar import nar_hash\nfrom pix.store_path import make_source_store_path\n\nh = nar_hash(\"./my-project\")\npath = make_source_store_path(\"my-project\", h)\n# '/nix/store/abc123...-my-project'\n</code></pre>"},{"location":"api/store_path/","title":"pix.store_path","text":"<p>Compute Nix store paths. A store path is <code>/nix/store/&lt;hash&gt;-&lt;name&gt;</code> where <code>&lt;hash&gt;</code> is 32 characters of Nix base32 encoding a 160-bit hash.</p> <p>See Internals: Store Paths for the full algorithm.</p>"},{"location":"api/store_path/#constants","title":"Constants","text":""},{"location":"api/store_path/#store_dir","title":"<code>STORE_DIR</code>","text":"<pre><code>STORE_DIR = \"/nix/store\"\n</code></pre>"},{"location":"api/store_path/#hash_bytes","title":"<code>HASH_BYTES</code>","text":"<pre><code>HASH_BYTES = 20  # 160 bits\n</code></pre>"},{"location":"api/store_path/#functions","title":"Functions","text":""},{"location":"api/store_path/#make_store_pathtype_prefix-str-inner_hash-bytes-name-str-str","title":"<code>make_store_path(type_prefix: str, inner_hash: bytes, name: str) -&gt; str</code>","text":"<p>Low-level store path computation. Most callers should use the typed helpers below.</p> <p>Computes the fingerprint <code>&lt;type&gt;:sha256:&lt;hex&gt;:/nix/store:&lt;name&gt;</code>, hashes it with SHA-256, XOR-folds to 20 bytes, and encodes in Nix base32.</p> <pre><code>from pix.store_path import make_store_path\nfrom pix.hash import sha256\n\nh = sha256(b\"some content\")\npath = make_store_path(\"text\", h, \"example.txt\")\n</code></pre>"},{"location":"api/store_path/#make_text_store_pathname-str-content-bytes-references-liststr-none-none-str","title":"<code>make_text_store_path(name: str, content: bytes, references: list[str] | None = None) -&gt; str</code>","text":"<p>Store path for a text file. Equivalent to <code>builtins.toFile</code> or <code>pkgs.writeText</code>.</p> <p>The inner hash is <code>sha256(content)</code>. The type prefix is <code>text</code> with references appended.</p> <pre><code>from pix.store_path import make_text_store_path\n\n# Simple text file\npath = make_text_store_path(\"hello.txt\", b\"hello world\")\n# '/nix/store/qbfcv31xi1wjisxwl4b2nk1a8jqxbcf5-hello.txt'\n\n# Text file that references another store path\npath = make_text_store_path(\n    \"script.sh\",\n    b\"#!/bin/sh\\nexec /nix/store/...-bash/bin/bash\",\n    references=[\"/nix/store/...-bash\"]\n)\n</code></pre>"},{"location":"api/store_path/#make_source_store_pathname-str-nar_hash-bytes-references-liststr-none-none-str","title":"<code>make_source_store_path(name: str, nar_hash: bytes, references: list[str] | None = None) -&gt; str</code>","text":"<p>Store path for a source directory or file. This is what happens when you use <code>builtins.path</code>, <code>filterSource</code>, or a bare path import in Nix.</p> <p>The inner hash is the SHA-256 of the NAR serialization.</p> <pre><code>from pix.store_path import make_source_store_path\nfrom pix.nar import nar_hash\n\nh = nar_hash(\"./my-project\")\npath = make_source_store_path(\"my-project\", h)\n</code></pre>"},{"location":"api/store_path/#make_fixed_output_pathname-str-hash_algo-str-content_hash-bytes-recursive-bool-false-str","title":"<code>make_fixed_output_path(name: str, hash_algo: str, content_hash: bytes, recursive: bool = False) -&gt; str</code>","text":"<p>Store path for a fixed-output derivation result (like <code>fetchurl</code>, <code>fetchgit</code>).</p> <pre><code>from pix.store_path import make_fixed_output_path\n\n# Flat file (fetchurl with sha256)\npath = make_fixed_output_path(\"source.tar.gz\", \"sha256\", hash_bytes)\n\n# Recursive (fetchgit, fetchFromGitHub)\npath = make_fixed_output_path(\"source\", \"sha256\", nar_hash_bytes, recursive=True)\n</code></pre> <p>Note</p> <p>For <code>recursive=True</code> with <code>sha256</code>, the path is computed as a source path directly (same as <code>make_source_store_path</code>). For other combinations, an intermediate hash is computed first.</p>"},{"location":"api/store_path/#make_output_pathdrv_hash-bytes-output_name-str-name-str-str","title":"<code>make_output_path(drv_hash: bytes, output_name: str, name: str) -&gt; str</code>","text":"<p>Store path for a derivation output, given the derivation's modular hash (from <code>hash_derivation_modulo</code>).</p> <pre><code>from pix.store_path import make_output_path\n\npath = make_output_path(drv_hash, \"out\", \"hello-2.12.2\")\n</code></pre>"},{"location":"internals/","title":"Internals","text":"<p>How Nix actually works \u2014 the formats, protocols, and algorithms, explained through the Python code that reimplements them.</p> <p>Each page pairs an explanation of the concept with pointers to the pix source that implements it. Read the page, then read the code \u2014 it should click.</p>"},{"location":"internals/#start-here","title":"Start here","text":"Page The question it answers Store Paths How does Nix compute <code>/nix/store/&lt;hash&gt;-&lt;name&gt;</code>? Why 32 characters? NAR Format What's inside a NAR archive? Why not tar? Daemon Protocol How do <code>nix build</code> and <code>nix-store</code> talk to the daemon? Derivations What's in a <code>.drv</code> file? How does <code>hashDerivationModulo</code> break the circular dependency? Base32 Encoding Why doesn't Nix use standard base32? What's different?"},{"location":"internals/#the-big-picture","title":"The big picture","text":"<p>When you write <code>nix build nixpkgs#hello</code>, here's what happens at the level pix operates:</p> <pre><code>1. Nix evaluates the expression \u2192 produces a Derivation\n\n2. The derivation is serialized to ATerm and written as a .drv file\n   (derivation.py can parse this back)\n\n3. Output paths in the .drv are computed via hashDerivationModulo:\n   - Hash the .drv with output paths blanked out\n   - Use that hash as the fingerprint for make_store_path\n   (derivation.py + store_path.py)\n\n4. The .drv is sent to the daemon via the Unix socket protocol\n   (daemon.py speaks this protocol)\n\n5. The daemon builds it:\n   - Realizes input sources (their store paths were computed\n     the same way, using NAR hashes \u2014 nar.py + store_path.py)\n   - Runs the builder\n   - Registers the output in the store database\n\n6. You can query the result via the daemon:\n   - is_valid_path, query_path_info\n   - The NAR hash and references are recorded\n</code></pre> <p>Each step has a corresponding pix module. The code is short enough that you can trace the entire flow.</p>"},{"location":"internals/base32/","title":"Nix Base32 Encoding","text":"<p>Nix uses a custom base32 encoding that differs from both RFC 4648 and other common base32 variants.</p>"},{"location":"internals/base32/#alphabet","title":"Alphabet","text":"<pre><code>Standard (RFC 4648):  A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 2 3 4 5 6 7\nNix:                  0 1 2 3 4 5 6 7 8 9 a b c d f g h i j k l m n p q r s v w x y z\n</code></pre> <p>The Nix alphabet has 32 characters: digits <code>0-9</code> and lowercase letters, but with <code>e</code>, <code>o</code>, <code>t</code>, <code>u</code> removed.</p> <p>Why these four? They could be confused with other characters (<code>e</code>/<code>3</code>, <code>o</code>/<code>0</code>, <code>t</code>/<code>+</code>), though the exact rationale is historical.</p>"},{"location":"internals/base32/#bit-extraction","title":"Bit extraction","text":"<p>This is where Nix base32 differs most significantly from RFC 4648. The bit extraction order is reversed.</p>"},{"location":"internals/base32/#rfc-4648-approach","title":"RFC 4648 approach","text":"<p>Standard base32 processes input left-to-right, taking 5-bit groups from the most significant bits first:</p> <pre><code>Input bytes:   [b0] [b1] [b2] ...\nBits:          76543210 76543210 76543210 ...\nGroups:        |4444433333|22222|11111|00000|...\n</code></pre>"},{"location":"internals/base32/#nix-approach","title":"Nix approach","text":"<p>Nix processes from the last 5-bit position down to the first, extracting bits across byte boundaries:</p> <pre><code>for i in range(out_len - 1, -1, -1):   # high positions first\n    b = i * 5\n    j = b // 8                          # byte index\n    k = b % 8                           # bit offset within byte\n    c = (data[j] &gt;&gt; k)                  # bits from byte j\n    if j + 1 &lt; len(data):\n        c |= data[j + 1] &lt;&lt; (8 - k)    # bits from byte j+1\n    output.append(CHARS[c &amp; 0x1f])\n</code></pre> <p>This means:</p> <ul> <li>The first output character encodes the highest 5-bit group</li> <li>Bits are extracted from the input in little-endian byte order</li> <li>Cross-byte extraction: a 5-bit group can span two adjacent input bytes</li> </ul>"},{"location":"internals/base32/#consequence","title":"Consequence","text":"<p>The same input bytes produce completely different outputs between RFC 4648 and Nix base32, even if you swap the alphabets. The encoding is structurally different, not just an alphabet substitution.</p>"},{"location":"internals/base32/#output-length","title":"Output length","text":"<p>For <code>n</code> input bytes, the output is <code>ceil(n * 8 / 5)</code> characters:</p> Input bytes Output chars Usage 0 0 \u2014 16 26 MD5 (not used by Nix) 20 32 Store path hashes 32 52 SHA-256 hashes 64 103 SHA-512 hashes"},{"location":"internals/base32/#decoding","title":"Decoding","text":"<p>Decoding reverses the process: iterate over the input string in reverse, placing 5-bit groups into the output byte array at the appropriate positions.</p> <pre><code>for i, ch in enumerate(reversed(s)):\n    digit = ALPHABET.index(ch)\n    b = i * 5\n    j = b // 8\n    k = b % 8\n    result[j] |= (digit &lt;&lt; k) &amp; 0xFF\n    carry = digit &gt;&gt; (8 - k)\n    if carry and j + 1 &lt; out_len:\n        result[j + 1] |= carry\n</code></pre>"},{"location":"internals/base32/#comparison-table","title":"Comparison table","text":"Property RFC 4648 Nix Alphabet <code>A-Z2-7</code> <code>0-9a-z</code> minus <code>eotu</code> Padding <code>=</code> pad to multiple of 8 chars No padding Bit order MSB-first, left-to-right LSB-first, right-to-left Case Case-insensitive Lowercase only Byte order Big-endian grouping Little-endian grouping"},{"location":"internals/base32/#example","title":"Example","text":"<p>SHA-256 of <code>\"hello\"</code>:</p> <pre><code>Hex:        2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824\nNix base32: 094qif9n4cq4fdg459qzbhg1c6wywawwaaivx0k0x8xhbyx4vwic\n</code></pre> <p>The same bytes in RFC 4648 base32 would produce a completely different (and longer, with padding) string.</p>"},{"location":"internals/daemon-protocol/","title":"Nix Daemon Protocol","text":"<p>The Nix daemon (<code>nix-daemon</code>) listens on a Unix domain socket and serves store operations to clients. pix implements a client for this protocol in pure Python.</p>"},{"location":"internals/daemon-protocol/#connection","title":"Connection","text":"<p>Socket path: <code>/nix/var/nix/daemon-socket/socket</code></p> <p>The socket is a <code>SOCK_STREAM</code> Unix domain socket. Each client gets a dedicated connection with sequential request/response exchanges.</p>"},{"location":"internals/daemon-protocol/#wire-format","title":"Wire format","text":"<p>All values on the wire use little-endian encoding, padded to 8-byte boundaries:</p> Type Encoding <code>uint64</code> 8 bytes, little-endian <code>bool</code> uint64 (0 = false, nonzero = true) <code>string</code> uint64(length) + bytes + zero-pad to 8 <code>string list</code> uint64(count) + count \u00d7 string <p>This is the same string encoding used in the NAR format.</p>"},{"location":"internals/daemon-protocol/#handshake","title":"Handshake","text":"<pre><code>Client                                          Daemon\n  \u2502                                               \u2502\n  \u251c\u2500\u2500\u2500 uint64(WORKER_MAGIC_1 = 0x6e697863) \u2500\u2500\u2500\u2500\u2500&gt;\u2502\n  \u2502                                               \u2502\n  \u2502&lt;\u2500\u2500 uint64(WORKER_MAGIC_2 = 0x6478696f) \u2500\u2500\u2500\u2500\u2500\u2500\u2524\n  \u2502&lt;\u2500\u2500 uint64(daemon_protocol_version) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n  \u2502                                               \u2502\n  \u251c\u2500\u2500\u2500 uint64(client_protocol_version) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502\n  \u251c\u2500\u2500\u2500 uint64(0)  [cpu affinity, obsolete] \u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502\n  \u251c\u2500\u2500\u2500 uint64(0)  [reserve space, obsolete] \u2500\u2500\u2500\u2500\u2500&gt;\u2502\n  \u2502                                               \u2502\n  \u2502&lt;\u2500\u2500 string(nix_version)  [if proto &gt;= 1.33] \u2500\u2500\u2524\n  \u2502&lt;\u2500\u2500 uint64(trusted)      [if proto &gt;= 1.35] \u2500\u2500\u2524\n  \u2502                                               \u2502\n  \u2502&lt;\u2500\u2500 STDERR_LAST \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n  \u2502                                               \u2502\n</code></pre> <p>Magic numbers:</p> Constant Value ASCII <code>WORKER_MAGIC_1</code> <code>0x6e697863</code> <code>nixc</code> <code>WORKER_MAGIC_2</code> <code>0x6478696f</code> <code>dxio</code> <p>Protocol version is encoded as <code>(major &lt;&lt; 8) | minor</code>. pix uses version <code>1.37</code> = <code>0x0125</code> = <code>293</code>.</p> <p>Trusted status (protocol &gt;= 1.35):</p> Value Meaning 0 Unknown 1 Trusted 2 Not trusted"},{"location":"internals/daemon-protocol/#requestresponse-pattern","title":"Request/response pattern","text":"<p>After the handshake, each operation follows this pattern:</p> <pre><code>Client                                          Daemon\n  \u2502                                               \u2502\n  \u251c\u2500\u2500\u2500 uint64(opcode) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502\n  \u251c\u2500\u2500\u2500 &lt;operation-specific data&gt; \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502\n  \u2502                                               \u2502\n  \u2502&lt;\u2500\u2500 stderr messages \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n  \u2502&lt;\u2500\u2500 STDERR_LAST \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n  \u2502&lt;\u2500\u2500 &lt;operation-specific response&gt; \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n  \u2502                                               \u2502\n</code></pre>"},{"location":"internals/daemon-protocol/#stderr-message-stream","title":"Stderr message stream","text":"<p>Between request and response, the daemon sends a stream of log messages. The client must drain these before reading the response.</p> <p>Each message starts with a uint64 message type:</p> Type Value Content <code>STDERR_LAST</code> <code>0x616c7473</code> End of stream \u2014 read the response next <code>STDERR_NEXT</code> <code>0x6f6c6d67</code> Log line: <code>string(message)</code> <code>STDERR_ERROR</code> <code>0x63787470</code> Error: <code>string(type) uint64(level) string(name) string(msg) uint64(n_traces) {uint64(pos) string(trace)}*</code> <code>STDERR_START_ACTIVITY</code> <code>0x53545254</code> Activity started: <code>uint64(id) uint64(level) uint64(type) string(text) fields uint64(parent)</code> <code>STDERR_STOP_ACTIVITY</code> <code>0x53544f50</code> Activity stopped: <code>uint64(id)</code> <code>STDERR_RESULT</code> <code>0x52534c54</code> Activity result: <code>uint64(id) uint64(type) fields</code> <p>Fields (used by activity messages):</p> <pre><code>uint64(count)\n{\n  uint64(type)     0 = uint64 value, 1 = string value\n  &lt;value&gt;\n}*\n</code></pre> <p>Always drain stderr</p> <p>You must read all stderr messages until <code>STDERR_LAST</code> before reading the operation response. Failing to do so will desynchronize the protocol.</p>"},{"location":"internals/daemon-protocol/#operations","title":"Operations","text":""},{"location":"internals/daemon-protocol/#isvalidpath-opcode-1","title":"<code>IsValidPath</code> (opcode 1)","text":"<p>Check if a store path is valid.</p> <pre><code>Request:  string(path)\nResponse: bool(valid)\n</code></pre>"},{"location":"internals/daemon-protocol/#addtexttostore-opcode-8","title":"<code>AddTextToStore</code> (opcode 8)","text":"<p>Add a text file to the store.</p> <pre><code>Request:  string(name) string(content) string_list(references)\nResponse: string(store_path)\n</code></pre>"},{"location":"internals/daemon-protocol/#buildpaths-opcode-9","title":"<code>BuildPaths</code> (opcode 9)","text":"<p>Build one or more paths.</p> <pre><code>Request:  string_list(paths) uint64(build_mode)\nResponse: uint64(result)\n</code></pre> <p>Build modes: 0 = normal, 1 = repair, 2 = check.</p> <p>Paths can be opaque store paths or <code>&lt;drv-path&gt;^&lt;output&gt;</code> for derivation outputs.</p>"},{"location":"internals/daemon-protocol/#querypathinfo-opcode-26","title":"<code>QueryPathInfo</code> (opcode 26)","text":"<p>Query metadata for a store path.</p> <pre><code>Request:  string(path)\nResponse: bool(valid)\n          [if valid:]\n          string(deriver)\n          string(nar_hash)\n          string_list(references)\n          uint64(registration_time)\n          uint64(nar_size)\n          bool(ultimate)\n          string_list(sigs)\n          string(content_address)\n</code></pre>"},{"location":"internals/daemon-protocol/#queryvalidpaths-opcode-31","title":"<code>QueryValidPaths</code> (opcode 31)","text":"<p>Batch validity check.</p> <pre><code>Request:  string_list(paths) bool(substitute)\nResponse: string_list(valid_paths)\n</code></pre>"},{"location":"internals/daemon-protocol/#protocol-version-history","title":"Protocol version history","text":"Version Changes 1.11 Reserve space flag in handshake 1.14 CPU affinity in handshake 1.16 <code>ultimate</code> flag in path info 1.17 <code>QueryPathInfo</code> returns validity bool instead of throwing 1.25 Content address field in path info 1.30 DerivedPath serialization for <code>BuildPaths</code> 1.33 Daemon sends nix version string after handshake 1.35 Daemon sends trusted status after handshake 1.37 Current version used by pix"},{"location":"internals/derivations/","title":"Derivations","text":"<p>A derivation is Nix's unit of build. It describes how to produce one or more store paths from inputs, a builder, and environment variables. Derivations are stored in the Nix store as <code>.drv</code> files in ATerm format.</p>"},{"location":"internals/derivations/#aterm-format","title":"ATerm format","text":"<p>A <code>.drv</code> file is a single ATerm expression:</p> <pre><code>Derive(\n  [(\"out\",\"/nix/store/...-hello\",\"\",\"\"), ...],       # outputs\n  [(\"/nix/store/...-dep.drv\",[\"out\"]), ...],         # input derivations\n  [\"/nix/store/...-source\", ...],                    # input sources\n  \"x86_64-linux\",                                    # platform\n  \"/nix/store/...-bash/bin/bash\",                    # builder\n  [\"--\", \"-e\", \"...\"],                               # arguments\n  [(\"key\",\"value\"), ...]                             # environment\n)\n</code></pre>"},{"location":"internals/derivations/#fields","title":"Fields","text":"# Field Type Description 1 outputs <code>[(name, path, hashAlgo, hash)]</code> Output name-to-path mapping 2 inputDrvs <code>[(drvPath, [outputNames])]</code> Derivation dependencies 3 inputSrcs <code>[path]</code> Source file dependencies 4 platform <code>string</code> Build platform (e.g. <code>x86_64-linux</code>) 5 builder <code>string</code> Path to the builder executable 6 args <code>[string]</code> Builder command-line arguments 7 env <code>[(key, value)]</code> Environment variables for the builder"},{"location":"internals/derivations/#outputs","title":"Outputs","text":"<p>Each output is a 4-tuple:</p> <pre><code>(\"name\", \"path\", \"hashAlgo\", \"hash\")\n</code></pre> Field Normal output Fixed-output <code>name</code> <code>\"out\"</code>, <code>\"lib\"</code>, <code>\"dev\"</code>, etc. <code>\"out\"</code> <code>path</code> <code>/nix/store/...-name</code> <code>/nix/store/...-name</code> <code>hashAlgo</code> <code>\"\"</code> <code>\"sha256\"</code>, <code>\"r:sha256\"</code>, etc. <code>hash</code> <code>\"\"</code> hex hash of expected content <p>The <code>r:</code> prefix in <code>hashAlgo</code> means recursive (NAR hash). Without it, the hash is of the flat file content.</p>"},{"location":"internals/derivations/#string-escaping","title":"String escaping","text":"<p>Strings in ATerm use these escape sequences:</p> Escape Character <code>\\\\</code> Backslash <code>\\\"</code> Double quote <code>\\n</code> Newline <code>\\r</code> Carriage return <code>\\t</code> Tab"},{"location":"internals/derivations/#ordering","title":"Ordering","text":"<p>In the canonical serialization:</p> <ul> <li>Outputs are sorted by output name</li> <li>Input derivations are sorted by <code>.drv</code> path</li> <li>Input sources are sorted</li> <li>Environment variables are sorted by key</li> <li>Arguments preserve their original order</li> </ul>"},{"location":"internals/derivations/#hashderivationmodulo","title":"<code>hashDerivationModulo</code>","text":"<p>This is the algorithm Nix uses to compute the hash that determines output paths. It exists to break circular dependencies \u2014 an output path depends on the derivation hash, but the derivation contains its own output paths.</p>"},{"location":"internals/derivations/#fixed-output-derivations","title":"Fixed-output derivations","text":"<p>For derivations with a single output <code>\"out\"</code> that has a <code>hashAlgo</code> set:</p> <pre><code>hash = sha256(\"fixed:out:&lt;hashAlgo&gt;:&lt;hashValue&gt;:\")\n</code></pre> <p>This means fixed-output derivations have stable hashes that don't change when their build dependencies change \u2014 only the expected output hash matters.</p>"},{"location":"internals/derivations/#regular-derivations","title":"Regular derivations","text":"<p>For all other derivations:</p> <ol> <li>Blank output paths: Replace all output paths with <code>\"\"</code></li> <li>Replace input drv paths: For each input derivation, replace the <code>.drv</code> path with the hex-encoded <code>hashDerivationModulo</code> of that input</li> <li>Serialize: Convert the masked derivation back to ATerm</li> <li>Hash: <code>sha256(serialized_masked_drv)</code></li> </ol> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Original .drv                           \u2502\n\u2502                                         \u2502\n\u2502 outputs: (\"out\", \"/nix/store/abc-x\")    \u2502\n\u2502 inputDrvs: (\"/nix/store/def.drv\",[\"out\"])\u2502\n\u2502 ...                                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                   \u2502\n            mask &amp; replace\n                   \u2502\n                   v\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Masked .drv                             \u2502\n\u2502                                         \u2502\n\u2502 outputs: (\"out\", \"\")        \u2190 blanked   \u2502\n\u2502 inputDrvs: (\"a1b2c3...\",[\"out\"]) \u2190 hash \u2502\n\u2502 ...                                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                   \u2502\n            serialize to ATerm string\n                   \u2502\n                   v\n            sha256(aterm_string)\n                   \u2502\n                   v\n           derivation hash (32 bytes)\n</code></pre>"},{"location":"internals/derivations/#computing-output-paths","title":"Computing output paths","text":"<p>Once you have the derivation hash from <code>hashDerivationModulo</code>:</p> <pre><code>from pix.store_path import make_output_path\n\noutput_path = make_output_path(drv_hash, \"out\", \"hello-2.12.2\")\n# /nix/store/&lt;hash&gt;-hello-2.12.2\n</code></pre> <p>The type prefix is <code>output:&lt;output-name&gt;</code>, so the fingerprint becomes:</p> <pre><code>output:out:sha256:&lt;hex(drv_hash)&gt;:/nix/store:hello-2.12.2\n</code></pre>"},{"location":"internals/derivations/#real-world-example","title":"Real-world example","text":"<p>A minimal derivation (<code>builtins.derivation { name = \"hello\"; builder = \"/bin/sh\"; args = [\"-c\" \"echo hello &gt; $out\"]; system = \"x86_64-linux\"; }</code>):</p> <pre><code>Derive(\n  [(\"out\",\"/nix/store/...-hello\",\"\",\"\")],\n  [],\n  [],\n  \"x86_64-linux\",\n  \"/bin/sh\",\n  [\"-c\",\"echo hello &gt; $out\"],\n  [(\"builder\",\"/bin/sh\"),\n   (\"name\",\"hello\"),\n   (\"out\",\"/nix/store/...-hello\"),\n   (\"system\",\"x86_64-linux\")]\n)\n</code></pre> <p>Note that the environment contains both explicit env vars and automatic ones (<code>builder</code>, <code>out</code>, <code>system</code>, <code>name</code>).</p>"},{"location":"internals/nar-format/","title":"NAR Wire Format","text":"<p>NAR (Nix Archive) is a deterministic archive format used by Nix to serialize filesystem trees. Its key property is reproducibility \u2014 the same filesystem content always produces the same byte sequence, regardless of timestamps, ownership, inode numbers, or other metadata.</p>"},{"location":"internals/nar-format/#wire-primitives","title":"Wire primitives","text":"<p>All data is framed using a single primitive:</p>"},{"location":"internals/nar-format/#stringblob-encoding","title":"String/blob encoding","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 uint64_le(len)   \u2502 raw bytes (len)    \u2502 zero padding\u2502\n\u2502 (8 bytes)        \u2502                    \u2502 to 8-byte   \u2502\n\u2502                  \u2502                    \u2502 boundary    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <ul> <li>Length is always a little-endian uint64 (8 bytes)</li> <li>Content follows immediately after the length</li> <li>Padding: <code>(8 - len % 8) % 8</code> zero bytes to reach 8-byte alignment</li> <li>Empty strings: length = 0, no content bytes, no padding</li> </ul> <p>Examples:</p> String Length (hex LE) Content Padding Total <code>\"\"</code> <code>00 00 00 00 00 00 00 00</code> (none) (none) 8 bytes <code>\"(\"</code> <code>01 00 00 00 00 00 00 00</code> <code>28</code> 7 zeros 16 bytes <code>\"type\"</code> <code>04 00 00 00 00 00 00 00</code> <code>74 79 70 65</code> 4 zeros 16 bytes <code>\"regular\"</code> <code>07 00 00 00 00 00 00 00</code> <code>72 65 67 75 6c 61 72</code> 1 zero 16 bytes <code>\"hello\"</code> <code>05 00 00 00 00 00 00 00</code> <code>68 65 6c 6c 6f</code> 3 zeros 16 bytes <p>Every token in NAR \u2014 keywords, names, content blobs \u2014 uses this same encoding.</p>"},{"location":"internals/nar-format/#grammar","title":"Grammar","text":"<pre><code>nar         = str(\"nix-archive-1\") node\n\nnode        = str(\"(\") entry str(\")\")\n\nentry       = str(\"type\") (regular | symlink | directory)\n\nregular     = str(\"regular\") [str(\"executable\") str(\"\")]\n              str(\"contents\") str(&lt;file-data&gt;)\n\nsymlink     = str(\"symlink\") str(\"target\") str(&lt;target-path&gt;)\n\ndirectory   = str(\"directory\") { dir_entry }\n\ndir_entry   = str(\"entry\") str(\"(\")\n              str(\"name\") str(&lt;entry-name&gt;)\n              str(\"node\") node\n              str(\")\")\n</code></pre> <p>Where <code>str(x)</code> is the wire encoding described above.</p>"},{"location":"internals/nar-format/#file-types","title":"File types","text":""},{"location":"internals/nar-format/#regular-file","title":"Regular file","text":"<pre><code>str(\"(\")\n  str(\"type\") str(\"regular\")\n  [str(\"executable\") str(\"\")]     \u2190 only if executable bit is set\n  str(\"contents\") str(&lt;data&gt;)\nstr(\")\")\n</code></pre> <p>The executable flag is the only permission information preserved. Mode bits like <code>0644</code> vs <code>0755</code> are reduced to just executable-or-not.</p>"},{"location":"internals/nar-format/#symlink","title":"Symlink","text":"<pre><code>str(\"(\")\n  str(\"type\") str(\"symlink\")\n  str(\"target\") str(&lt;target&gt;)\nstr(\")\")\n</code></pre> <p>The target is stored as-is (not resolved). Relative and absolute symlinks are both supported.</p>"},{"location":"internals/nar-format/#directory","title":"Directory","text":"<pre><code>str(\"(\")\n  str(\"type\") str(\"directory\")\n  str(\"entry\") str(\"(\")\n    str(\"name\") str(\"a.txt\")\n    str(\"node\") &lt;recursive node for a.txt&gt;\n  str(\")\")\n  str(\"entry\") str(\"(\")\n    str(\"name\") str(\"b.txt\")\n    str(\"node\") &lt;recursive node for b.txt&gt;\n  str(\")\")\nstr(\")\")\n</code></pre> <p>Entries must be sorted</p> <p>Directory entries must be sorted lexicographically by name. This is critical for determinism.</p>"},{"location":"internals/nar-format/#what-nar-preserves","title":"What NAR preserves","text":"Preserved Not preserved File contents Timestamps (mtime, ctime, atime) File type (regular, symlink, directory) Ownership (uid, gid) Executable bit Permission mode (beyond +x) Symlink targets Inode numbers Directory structure Extended attributes Entry names Hard links (serialized as separate files)"},{"location":"internals/nar-format/#worked-example","title":"Worked example","text":"<p>NAR serialization of a file containing <code>\"hello\"</code> (5 bytes, not executable):</p> <pre><code>Offset  Bytes                           Meaning\n------  -----                           -------\n0x00    0e 00 00 00 00 00 00 00         length of \"nix-archive-1\" = 14\n0x08    6e 69 78 2d 61 72 63 68         \"nix-arch\"\n0x10    69 76 65 2d 31 00 00 00         \"ive-1\" + 2 bytes padding\n0x18    01 00 00 00 00 00 00 00         length of \"(\" = 1\n0x20    28 00 00 00 00 00 00 00         \"(\" + 7 bytes padding\n0x28    04 00 00 00 00 00 00 00         length of \"type\" = 4\n0x30    74 79 70 65 00 00 00 00         \"type\" + 4 bytes padding\n0x38    07 00 00 00 00 00 00 00         length of \"regular\" = 7\n0x40    72 65 67 75 6c 61 72 00         \"regular\" + 1 byte padding\n0x48    08 00 00 00 00 00 00 00         length of \"contents\" = 8\n0x50    63 6f 6e 74 65 6e 74 73         \"contents\" (no padding needed)\n0x58    05 00 00 00 00 00 00 00         length of content = 5\n0x60    68 65 6c 6c 6f 00 00 00         \"hello\" + 3 bytes padding\n0x68    01 00 00 00 00 00 00 00         length of \")\" = 1\n0x70    29 00 00 00 00 00 00 00         \")\" + 7 bytes padding\n\nTotal: 120 bytes\nSHA-256: 0a430879c266f8b57f4092a0f935cf3facd48bbccde5760d4748ca4051716969\n</code></pre> <p>This matches the output of <code>nix hash path</code> for a file containing <code>\"hello\"</code>.</p>"},{"location":"internals/store-paths/","title":"Store Path Computation","text":"<p>A Nix store path is a string of the form:</p> <pre><code>/nix/store/&lt;hash&gt;-&lt;name&gt;\n</code></pre> <p>where <code>&lt;hash&gt;</code> is exactly 32 characters of Nix base32, encoding a 160-bit (20-byte) hash.</p>"},{"location":"internals/store-paths/#algorithm","title":"Algorithm","text":"<pre><code>                              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  content \u2500\u2500\u2500\u2500 sha256 \u2500\u2500\u2500\u2500\u2500\u2500&gt; \u2502  inner   \u2502\n  (or NAR hash for source)    \u2502  hash    \u2502\n                              \u2502 (32 B)   \u2502\n                              \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518\n                                   \u2502\n                                   v\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502 fingerprint string:                                \u2502\n  \u2502 \"&lt;type&gt;:sha256:&lt;hex(inner_hash)&gt;:/nix/store:&lt;name&gt;\"\u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                          \u2502\n                      sha256\n                          \u2502\n                          v\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502 32 bytes \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518\n                         \u2502\n                  XOR-fold to 20 bytes\n                         \u2502\n                         v\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502 20 bytes \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518\n                         \u2502\n                  Nix base32 encode\n                         \u2502\n                         v\n      /nix/store/&lt;32 chars&gt;-&lt;name&gt;\n</code></pre>"},{"location":"internals/store-paths/#type-prefixes","title":"Type prefixes","text":"<p>The <code>&lt;type&gt;</code> in the fingerprint determines what kind of store object this path refers to.</p>"},{"location":"internals/store-paths/#text-text-files","title":"<code>text</code> \u2014 Text files","text":"<p>Used by <code>builtins.toFile</code> and <code>pkgs.writeText</code>. The inner hash is <code>sha256(content)</code>.</p> <pre><code>text:sha256:&lt;hex&gt;:/nix/store:&lt;name&gt;\n</code></pre> <p>With references (the text file depends on other store paths):</p> <pre><code>text:/nix/store/...-dep1:/nix/store/...-dep2:sha256:&lt;hex&gt;:/nix/store:&lt;name&gt;\n</code></pre> <p>References are sorted and appended with <code>:</code> separators. When there are no references, the type is just <code>text</code> \u2014 no trailing colon.</p>"},{"location":"internals/store-paths/#source-source-paths","title":"<code>source</code> \u2014 Source paths","text":"<p>Used by <code>builtins.path</code>, <code>builtins.filterSource</code>, and bare path imports (<code>./foo</code>). The inner hash is the SHA-256 of the NAR serialization.</p> <pre><code>source:sha256:&lt;hex&gt;:/nix/store:&lt;name&gt;\n</code></pre> <p>Can also have references (self-references for paths that contain their own store path):</p> <pre><code>source:/nix/store/...-self:sha256:&lt;hex&gt;:/nix/store:&lt;name&gt;\n</code></pre>"},{"location":"internals/store-paths/#outputname-derivation-outputs","title":"<code>output:&lt;name&gt;</code> \u2014 Derivation outputs","text":"<p>Used for the outputs of non-fixed-output derivations. The inner hash comes from <code>hashDerivationModulo</code>.</p> <pre><code>output:out:sha256:&lt;hex&gt;:/nix/store:&lt;name&gt;\n</code></pre> <p>For multi-output derivations:</p> <pre><code>output:lib:sha256:&lt;hex&gt;:/nix/store:&lt;name&gt;\noutput:dev:sha256:&lt;hex&gt;:/nix/store:&lt;name&gt;\n</code></pre>"},{"location":"internals/store-paths/#fixed-output-derivations","title":"Fixed-output derivations","text":"<p>Fixed-output derivations (like <code>fetchurl</code>) use a two-step process:</p> <ol> <li>Compute an intermediate descriptor: <code>fixed:out:&lt;method&gt;&lt;algo&gt;:&lt;hex&gt;:</code></li> <li>Hash that descriptor: <code>inner_hash = sha256(descriptor)</code></li> <li>Use <code>output:out</code> as the type</li> </ol> <p>Exception: <code>recursive</code> + <code>sha256</code> is treated as a source path directly (same as <code>make_source_store_path</code>).</p>"},{"location":"internals/store-paths/#name-constraints","title":"Name constraints","text":"<p>Store object names must:</p> <ul> <li>Not be empty</li> <li>Not start with <code>.</code></li> <li>Contain only: <code>a-z A-Z 0-9 + - . _ ? =</code></li> <li>Not exceed 211 characters</li> </ul>"},{"location":"internals/store-paths/#worked-example","title":"Worked example","text":"<p>Computing the store path for <code>builtins.toFile \"hello.txt\" \"hello\"</code>:</p> <pre><code>from pix.hash import sha256, compress_hash\nfrom pix.base32 import encode\n\ncontent = b\"hello\"\n\n# Step 1: inner hash\ninner = sha256(content)\n# 2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824\n\n# Step 2: fingerprint\nfp = f\"text:sha256:{inner.hex()}:/nix/store:hello.txt\"\n# text:sha256:2cf24dba...938b9824:/nix/store:hello.txt\n\n# Step 3: hash the fingerprint\nfp_hash = sha256(fp.encode())\n\n# Step 4: compress\ncompressed = compress_hash(fp_hash, 20)\n\n# Step 5: encode\nencoded = encode(compressed)  # 32 chars\n\n# Step 6: assemble\npath = f\"/nix/store/{encoded}-hello.txt\"\n</code></pre>"}]}